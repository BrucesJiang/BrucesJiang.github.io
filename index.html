<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="忆往昔之不谏，知来者犹可追">
<meta property="og:type" content="website">
<meta property="og:title" content="枫的杂货铺">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="枫的杂货铺">
<meta property="og:description" content="忆往昔之不谏，知来者犹可追">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Bruce Jiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>枫的杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">枫的杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/29/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E5%A4%A9%E7%BD%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/29/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E5%A4%A9%E7%BD%A1/" class="post-title-link" itemprop="url">画江湖之天罡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-29 18:58:32 / 修改时间：20:24:51" itemprop="dateCreated datePublished" datetime="2023-12-29T18:58:32+08:00">2023-12-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/../image/%E5%A4%A9%E7%BD%A1%E4%BC%A0.png" alt="天罡传"></p>
<p>期待已久的又一国漫力作，不良人首部系列电影终于上映了。从前坚决不买任何会员的我，也是第一时间给腾讯视频充值一把，就目前而言，18元的云播形式物超所值（此处没有任何广告，不适者可忽略）。</p>
<p>权且称作天罡传第一部，故事涵盖时间跨度较长，经历了唐太宗，唐高宗，武周以及唐玄宗四朝。但是故事的时间范围大多还是锁定在武周后期的“神龙政变”事件前后。整个故事是以袁天罡为了完成好友李淳风遗愿作为推进主线，时间线上分为三个阶段推进故事，中间铺垫和穿插了某些故事背景。</p>
<p>第一阶段发生在贞观朝，大致为贞观末年。此时袁天罡已经身居国师一职，一边占卜星象祈福国运，一边与好友李淳风合力为皇帝炼制不死药(唐太宗末年确有其事)。在剧情中大约为贞观二十年(646年)，二人炼成长生药献给唐太宗，但是袁天罡在试药失败毁容(但是获得了长生之法)。经此巨变，袁天罡便辞去国师一职，太宗不愿其一生本领就此埋没，因此，创建了专为皇室服务的不良人组织，以袁天罡为帅——不良帅也正式上线.</p>
<p>第二阶段故事线大致为唐高宗咸亨元年(公元670年，历史上当前李淳风逝世)，这也是本片明线故事推进的引子。此时时间线已经向后推进几十年，顺应天道的李淳风，在即将离世前对袁天罡(袁天罡历史上生卒不详，但是隋大业年就已经在朝担任官职，此时至少90高龄)，俏皮地说出了：“我前些日子起了一卦，我到时候了。物有生死，理有存亡，不死之法，遁天妄行，远不如知己伴我离世来的惬意。对不住了，袁兄，以后你就要一个人了”。这也是中国哲人面对死亡时的洒脱，面对所谓长生时的不屑。</p>
<p><img src="/../image/%E5%A4%A9%E7%BD%A1%E4%BC%A0-%E6%9D%8E%E6%B7%B3%E9%A3%8E.png" alt="李淳风"></p>
<p>第三阶段大致为武周天授二年（691年），也是这部电影的核心内容。大致推测是，大帅留下一纸书信辞官而去。随着大帅的离开，朝堂上失去了顶梁柱。也正是在此时，武皇男宠章五郎，奸臣当道。明线，大帅为了完成老友遗愿，为老友寻找埋骨之地云游四海。同时，带着一个一心复仇复仇的小姑娘-樊巧儿(个人猜测就是一个菜单，暗示这就是未来的四大尸祖之首-将臣)。暗线则是，皇子李显一系的李家王朝的坚定支持者——张柬之，进入视野，期望借助不良帅之手推动政变。当然，在张柬之有意无意的暗示，李淳风最后一个极囊中的空无一物，以及这一路上的种种，都为袁天罡最后看清自己的内心添加了一把火。同样为袁天罡解决心中的疑惑，寻找未来百年，甚至千年活下去的信念，提供了一颗指明星。 最终将故事推向了高潮，不良帅履行了自己的职责，返回皇宫，挽狂澜于既倒。击败了同样拥有不死之身的章五郎，就出被软禁的武皇，最后假死。</p>
<p>通篇而言，我个人觉得电影的故事线很完整，稍有历史背景，不跳播，基本都能看得懂故事。当然，也能理解电影背后的某些历史事件，人物，以及在此之上必要虚构。不得不说的是，真个电影的画面感超好，每一帧的细节处理的也相当到位，是一部非常值得推荐的国漫电影。</p>
<p>最后，看看我不良帅冰冷霸气地回眸。<br><img src="/../image/%E8%A2%81%E5%A4%A9%E7%BD%A1.png" alt="袁天罡"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/%E9%95%BF%E5%AE%89%E4%B8%89%E4%B8%87%E9%87%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/%E9%95%BF%E5%AE%89%E4%B8%89%E4%B8%87%E9%87%8C/" class="post-title-link" itemprop="url">长安三万里</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-09 21:48:12" itemprop="dateCreated datePublished" datetime="2023-09-09T21:48:12+08:00">2023-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-10 00:20:16" itemprop="dateModified" datetime="2023-09-10T00:20:16+08:00">2023-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中华文化五千历史长河，《长安长安三万里》仅撰取其中约六十年的历史片段，其意不在时间之长，而在内容之厚。—— 题记</p>
<p>《长安三万里》与其说是一部动漫，倒不如说是一部梗概的正剧。以唐玄宗，唐肃宗，唐代宗三朝尺度书写大唐由盛及衰的约60年历史。上到达官贵人，下到黎民百姓，描绘了唐时社会风貌。以高适和李白交织的命运，引出了历史中我们耳熟能详的历史人物，崔颢，李白，杜甫，高适，王维，哥舒翰，郭子仪 …… </p>
<h2 id="历史的长安"><a href="#历史的长安" class="headerlink" title="历史的长安"></a>历史的长安</h2><p>历史的长安，既是长安，又不仅仅是长安。长安，在大唐约二十帝二百九十年的历史中，大多数时间都是政治和经济的中心，同样也是当时世界为数不多的有巨大影响力的政治与经济中心。 “长安回望绣成堆，山顶千门次第开”，远远观望是长安；“闻道长安灯夜好，雕轮宝马如云”，近看亦是长安；“玉辇纵横过主第，金鞭络绎向侯家”，达官贵人是长安；“长安一片月，万户捣衣声”，黎民百姓亦是长安…… 三万里的长安，是一种象征，其代表的不仅仅是长安一城，更是盛唐气象的代表。就文学而言，诗之巅峰在唐，高棅在《唐诗品汇》总序说：“李翰林之飘逸，杜工部之沉郁，孟襄阳之清雅，王右丞之精致，储光羲之真率，王昌龄之声俊，高适、岑参之悲壮，李颀、常建之超凡，此盛唐之盛也。”</p>
<h2 id="命运的长安"><a href="#命运的长安" class="headerlink" title="命运的长安"></a>命运的长安</h2><p>在那时，到长安去的人，各有各的理想和信念。无论是走农村包围城市的路线，还是走城市拓展乡野的的策略，各有各的路径，各有各的基石。李白和高适是命运交织的两个人，两人相识于乡野，相伴于游历功名，相别于理想抱负，一个高开低走，一个低开高走。<br>一生高开低走的李白，从一开始就是“五花马，千金裘”的公子哥儿，但是命运的转折来自于富商父亲的去世，公子哥儿的人生开始走下坡路，这里也仅仅是生活。在政治抱负上，受制于三教九流的商贾身份，李白从来没有得意，只有无尽的失意。生活上的得意和政治抱负上的失意，也影响到了他的诗风，“大鹏一日同风起，扶摇直上九万里”，尽显年轻人的英气；“长风破浪会有时，直挂云帆济沧海”，尽显中年人的失意；“两岸猿声啼不住，轻舟已过万重山”，晚年的如释重负。<br>正如李白所言：“高兄，你心中的一团锦绣，总有出口的一天！”,低开高走的高适，前半生时平平无奇的。高适所在的唐朝，是中国历史上无可辩驳的诗歌盛世，更有李白、杜甫、王维、孟浩然、李贺…… 都是横行一世的猛人，在文学上却偏要挤在一段如此狭小的时间里，高适只能徒呼哀哉。但是，“战士军前半死生，美人帐下犹歌舞”;“少妇城南欲断肠，征人蓟北空回首” 等边塞诗，仍旧让他在文学上不乏佳作。天命之年封侯，高适的人生，就是想一瓶后劲十足十足的老酒，历久弥香——50岁前，无人问津，一事无成，甚至家徒四壁、颠沛流离；50岁后，尽心尽责、为国效力，平步青云。从事业的角度来看，50岁，才是高适人生真正的起点。</p>
<p>163分钟时长的《长安三万里》，从高适的视角讲述了高适和李白交织的一生，其勾勒了盛世文人群像，也描绘了一个王朝由盛至衰的历史，与其说是一部动漫，更不如说是一部历史正剧的梗概，极尽中国水墨风格，浓厚的历史风味。正如高适所说，“黄鹤楼虽然被毁，但是只要诗在，黄鹤楼就在”，我要说，只要诗在，长安就在。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">常见限流算法小结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-20 17:58:34" itemprop="dateCreated datePublished" datetime="2023-08-20T17:58:34+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-27 11:28:25" itemprop="dateModified" datetime="2023-08-27T11:28:25+08:00">2023-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>常见的限流算法有四种： 固定窗口限流算法、滑动窗口限流算法、漏桶限流算法和令牌桶限流算法。</p>
<h1 id="固定窗口限流算法-Fixed-Window-Algorithm"><a href="#固定窗口限流算法-Fixed-Window-Algorithm" class="headerlink" title="固定窗口限流算法(Fixed Window Algorithm)"></a>固定窗口限流算法(Fixed Window Algorithm)</h1><p>将时间划分为固定的窗口，统计每个窗口期内的请求量，如果请求流超过窗口阈值，则拒绝请求。        </p>
<h1 id="滑动窗口限流算法-Sliding-Window-Algorithm"><a href="#滑动窗口限流算法-Sliding-Window-Algorithm" class="headerlink" title="滑动窗口限流算法(Sliding Window Algorithm)"></a>滑动窗口限流算法(Sliding Window Algorithm)</h1><h1 id="漏桶限流算法-Leaky-Bucket-Algorithm"><a href="#漏桶限流算法-Leaky-Bucket-Algorithm" class="headerlink" title="漏桶限流算法(Leaky Bucket Algorithm)"></a>漏桶限流算法(Leaky Bucket Algorithm)</h1><h1 id="令牌桶限流算法-Token-Bucket-Algorithm"><a href="#令牌桶限流算法-Token-Bucket-Algorithm" class="headerlink" title="令牌桶限流算法(Token Bucket Algorithm)"></a>令牌桶限流算法(Token Bucket Algorithm)</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/19/%E6%95%B0%E6%8D%AE%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/19/%E6%95%B0%E6%8D%AE%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据放置算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-19 11:26:42" itemprop="dateCreated datePublished" datetime="2023-08-19T11:26:42+08:00">2023-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-20 17:58:41" itemprop="dateModified" datetime="2023-08-20T17:58:41+08:00">2023-08-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文主要介绍几种常见的数据放置算法: <strong>轮流放置(Round Robin)、一致性哈希算法(Consistent Hash)、q区间划分(Range-based Partitioning)</strong></p>
<h1 id="轮流放置"><a href="#轮流放置" class="headerlink" title="轮流放置"></a>轮流放置</h1><p>每条元素都会被放置在下一个节点上，以此进行循环。 一般在实际应用中为了处理方便，通常按照主键的值来决定次序从而进行划分。即给定一个表T，表T的划分键(Partition Key)是K, 需要划分的节点数目N， 那么元组属于T将会被放置在<em>n</em>个节点上面，其中<code>n = t*k mod N </code>由于划分只与划分键有关，因此，我们可以把对元组的划分简化为对数字的划分，对于不是数字的键值可以通过其他方式比如哈希转化为数字形式。 下例，将9个元组分布到三个节点上：</p>
<p><img src="/../image/algorithm/round_robin.png"></p>
<p>简单的直接划分键上的值来计算放置节点的算法可能会造成数据的分布不均匀。因此，轮流放置有很多改进版本，例如哈希方式，也就是 n &#x3D; hash(t.k) mod N 。现将划分键的值进行hash操作，变成一个与输入无关、均匀输出的值，然后再进行取模操作。</p>
<ul>
<li>优点: 轮流放置算法实现非常简单，几乎不需要元数据就可以进行路由查询。</li>
<li>缺点: 当系统中添加或者删除节点时，数据迁移的工作量会非常大。</li>
</ul>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p>将value映射到一个32维的key值，也即是<code>0 ~  2^32 - 1</code>的数值空间，可以将这个空间想象成一个首(0)尾(<code>2^32 - 1</code>)相接的圆环，如下图所示：<br><img src="/../image/algorithm/consistent_hash_01.png"></p>
<p>将存储对象和存储服务器分别哈希到环上:<br><img src="/../image/algorithm/consistent_hash_02.png"><br><img src="/../image/algorithm/consistent_hash_03.png"></p>
<p>存储对象按一致的方向落在离它最近的服务器上。<br>优点:</p>
<ul>
<li>均匀 由于采用的哈希函数通常是与输入无关的均匀函数，因此当键值和节点都非常多的时候，一致性哈希可以达到很好的分布式均匀性。</li>
<li>哈希环的偏斜: 由于哈希函数的选择导致存储对象和存储服务器哈希到环上时分布不均匀，服务器资源没有得到充分利用，缓存分布极度不均匀。 可以采用虚拟节点的方式解决哈希环倾斜的问题</li>
<li>迁移时数据量少 : 由于特殊的放置规则，一致性哈希在节点数据发生变动时可以将影响控制在局部区域内，从而较少的数据迁移(接近理论上的最小值)。当增加一饿节点时，只有这个节点所在的区间内的数据需要被重新划分。如下图中，只需要将range 2上面的数据会从node 1中迁移到node 3上面。当删除一个节点时，只需要将这个节点上面的数据迁移到下一个节点上面，比如删除node 3，只把range 2上面的数据迁移到node 1上面就可以并，而其它的数据是不需要迁移变动的。<br><img src="/../image/algorithm/consistent_hash_04.png"></li>
</ul>
<h1 id="区间划分"><a href="#区间划分" class="headerlink" title="区间划分"></a>区间划分</h1><p>现在很热门的NoSQL数据库MongoDB的sharding方案中所使用的算法。系统首先会把所有数据划分为多个区间，然后再将这些区间分配到系统的各个节点上。最简单的区间划分是一个节点只持有一个区间：在有N个节点的情况下，将划分键的取值区间均匀划分为n份，然后每个节点持有一块。如果发生数据分布不均匀的情况，可以通过调整区间分布达到均匀情况，数据迁移同样会很小。</p>
<p><img src="/../image/algorithm/rang_based_partition_01.png"></p>
<p>优势</p>
<ul>
<li>数据分布不均匀导致的数据连锁迁移<br><img src="/../image/algorithm/rang_based_partition_02.png"></li>
<li>增加或删除节点导致的数据连锁迁移<br><img src="/../image/algorithm/rang_based_partition_03.png"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/24/Redis%E7%9A%84hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/24/Redis%E7%9A%84hashtable/" class="post-title-link" itemprop="url">Redis的hashtable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-24 16:04:19" itemprop="dateCreated datePublished" datetime="2023-06-24T16:04:19+08:00">2023-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-19 11:26:47" itemprop="dateModified" datetime="2023-08-19T11:26:47+08:00">2023-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis的Dictionary"><a href="#Redis的Dictionary" class="headerlink" title="Redis的Dictionary"></a>Redis的Dictionary</h1><p>字典，又称作符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p>
<p>字典中，一个键(key)和一个值(value)进行关联，这线关联的键和值称之为键值对。</p>
<p>Redis的字典使用哈希表作为底层，一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存了字典中的键值对。</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>Redis字典使用的哈希表在<code>dict.c/dict.h</code> (代码为<code>6.0.0</code>版本)中定义实现。</p>
<p>哈希表定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 哈希表已有节点数量s</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<ul>
<li>table 是一个数组，数组中每一个元素都是一个指向<code>dict.h/dictEntry</code>的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val; </span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/24/Redis%E7%9A%84ziplist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/24/Redis%E7%9A%84ziplist/" class="post-title-link" itemprop="url">Redis的ziplist</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-24 11:23:37 / 修改时间：17:05:06" itemprop="dateCreated datePublished" datetime="2023-06-24T11:23:37+08:00">2023-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis-压缩表-ziplist"><a href="#Redis-压缩表-ziplist" class="headerlink" title="Redis 压缩表(ziplist)"></a>Redis 压缩表(ziplist)</h1><p>压缩列表(ziplist)是列表键和哈希键的低层实现之一。当一个列表键只包含数量列表项，并每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的低层实现。</p>
<h2 id="压缩列表结构"><a href="#压缩列表结构" class="headerlink" title="压缩列表结构"></a>压缩列表结构</h2><p>压缩列表是Redis为了节约内存开发的，是有一系列特殊编码的连续内存块儿组成的顺序型(sequential)数据结构。一个压缩列表可以包含热议多个节点(entry)，每个节点可以保存一个字节数组或者一个整数值。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>参考源代码实现(ziplist.h&#x2F;zipslist.c), 代码为6.0.0版本， 压缩列表的各个组成部分：</p>
<p><img src="/../image/redis/ziplist_components.jpg" alt="ziplist"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录整个压缩列表占用内存的字节数，在对压缩列表进行内存从新分配或者计算zlend的位置时使用</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录压缩列表尾节点距离压缩列表的起始地址有多少个字节：通过这个偏移量，程序无需便利整个压缩列表就可以确定尾节点的起始地址</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_6</td>
<td>2字节</td>
<td>记录压缩列表包含的节点数量，当这个属性的值小于UINT16_MAX(65535）时，这个属性的值就是压缩列表包含节点的数量，当这个值等于UINT16_MAX时，节点的真实数量需要便利整个压缩列表才能计算出</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1字节</td>
<td>特殊值0xFF(十进制255)， 用于标记压缩列表的末端</td>
</tr>
</tbody></table>
<h3 id="压缩列表节点"><a href="#压缩列表节点" class="headerlink" title="压缩列表节点"></a>压缩列表节点</h3><p>每个压缩列表节点可以保存一个字节数组或一个整数值。<br>字节数组可以十以下三种长度的一种：</p>
<ul>
<li>长度小于等于64(2^6 - 1) 字节的字节数组</li>
<li>长度小于等于16383(2^14 - 1) 字节的字节数组</li>
<li>长度小于4294967295(2^32 - 1）字节的字节数组</li>
</ul>
<p>整数值则可以为以下六种长度之一：</p>
<ul>
<li>4位长，介于0~12之间的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul>
<p>压缩列表节点组成如下:<br><img src="/../image/redis/ziplist_entry.jpg" alt="ziplist"></p>
<ul>
<li>previous_entry_length 节点的previous_entry_length属性以字节位单位，记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或5字节.<ul>
<li>如果前一个节点的长度小于254， 那么previous_entry_length属性的长度为1字节，用于保存前一个节点的长度</li>
<li>如果前一个节点的长度大于或等于254，那么previous_entry_length属性长度为5字节，其中是属性的第一字节被设置为0xPE(十进制254),而之后的四个字节用于保存前一个节点的长度</li>
</ul>
</li>
<li>encoding 节点的content属性保存数的类型以及长度<ul>
<li>一字节、两字节或五字节长，值的最高位00、01或10的是字节数组编码，这种编码表示节点的content属性保存的是字节数组、数组的长度由编码除去最高两位之后的其他位记录</li>
<li>一字节长，值的最高位以11开头的编码是整数编码，这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录</li>
</ul>
</li>
<li>content 保存节点的值，节点值可以位一个字节数组或整数，值的类型和长度由节点的encoding属性决定</li>
</ul>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>压缩链表每个节点的previous_entry_length属性都记录了前一个节点的长度：</p>
<ul>
<li>前一个节点的长度小于254字节，previous_entry_length属性需要用1个字节长的空间来保存这个长度值</li>
<li>前一个节点的长度大于等于254字节，previous_entry_length属性需要用5个字节长的空间来保存这个长度值</li>
</ul>
<p>假设这种情况，在一个压缩列表中，有多个连续的、长度介于250<del>253字节之间的节点e1\</del>eN</p>
<p><img src="/../image/redis/cascade_update.jpg" alt="cascade update"></p>
<p>将一个长度大于等于254字节的新节点new设置为压缩列表的头节点，那么new将变为e1的前置节点。由于e1的previous_entry_length属性仅1个字节长，没有办法保存new的长度，此时会触发压缩列表的空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节扩展为5字节。此时，由于e1节点的扩充，e2节点previous_entry_length属性无法保存e1节点的长度，继续触发空间重分配，直至eN扩充完毕。 这种特殊情况产生的连续多次空间扩展操作称之为”连锁更新”(cascade update)。 最坏情况下，每次对压缩空间充分配时间复杂度为O(N)， 连锁更新的时间复杂度为O(N^2), N为节点数量。</p>
<h2 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>ziplistNew</td>
<td>创建一个新的压缩列表</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistPush</td>
<td>创建一个包含指定值的新节点，并将这个节点添加到压缩列表的表头或表尾</td>
<td>平均O(N)，最坏O(N)</td>
</tr>
<tr>
<td>ziplistInsert</td>
<td>将包含给定值的新节点插入到给定节点之后</td>
<td>平均O(N), 最坏O(N^2)</td>
</tr>
<tr>
<td>ziplistIndex</td>
<td>返回压缩列表给定索引上的节点</td>
<td>O(N)</td>
</tr>
<tr>
<td>ziplistFind</td>
<td>在压缩列表中查找并返回包含了给定值的节点</td>
<td>O(N*M), N压缩列表节点个数，M为节点字节数组长度</td>
</tr>
<tr>
<td>ziplistNext</td>
<td>返回给定节点的下一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistPrev</td>
<td>返回给定节点的上一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistGet</td>
<td>获取给定节点保存的值</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistDelete</td>
<td>从压缩列表中删除给定的节点</td>
<td>平均O(N)， 最坏 O(N^2)</td>
</tr>
<tr>
<td>ziplistDeleteRange</td>
<td>删除压缩列表中给定索引上的连续多个节点</td>
<td>平均O(N)， 最坏 O(N^2)</td>
</tr>
<tr>
<td>ziplistBlobLen</td>
<td>返回压缩列表目前占用的内存字节数</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistLen</td>
<td>返回压缩列表目前包含的节点数</td>
<td>节点数量小于65535时为O(1)， 大于65535时为O(N)</td>
</tr>
</tbody></table>
<h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/23/SpringBoot%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/23/SpringBoot%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/" class="post-title-link" itemprop="url">SpringBoot如何启动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-23 16:07:30" itemprop="dateCreated datePublished" datetime="2023-06-23T16:07:30+08:00">2023-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-26 22:50:35" itemprop="dateModified" datetime="2023-12-26T22:50:35+08:00">2023-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>启动类 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.bruce.jyn&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ImportResource(&#123;&quot;classpath*:demo.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PandoraBootstrap.run(args);</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">        PandoraBootstrap.markStartupAndWait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;[], java.lang.String[])</code>，主要干了两件事儿:</p>
<ol>
<li>初始化 <code>SpringApplication</code>对象</li>
<li>调用 <code>run</code> 方法</li>
<li>初始化 <code>SpringApplication</code>时，将<code>primarySources</code> 设置到<code>SpringApplication</code>中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;[], java.lang.String[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SpringApplication</code>构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    <span class="built_in">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">    <span class="built_in">this</span>.logStartupInfo = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.addCommandLineProperties = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.addConversionService = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.headless = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.registerShutdownHook = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.additionalProfiles = Collections.emptySet();</span><br><span class="line">    <span class="built_in">this</span>.isCustomEnvironment = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.lazyInitialization = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    <span class="built_in">this</span>.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    <span class="comment">// 资源加载器</span></span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// primarySources参数设置</span></span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 判断应用类型，判断是否是web程序，并设置到webEnvironment的boolean属性中</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="built_in">this</span>.getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 获取所有初始化器， 创建并初始化ApplectionInitializer（初始化器），设置到initializers属性中</span></span><br><span class="line">    <span class="built_in">this</span>.setInitializers(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">     <span class="comment">// 获取所有监听器，创建并初始化ApplicationListener（初监听器），设置到listeners属性中</span></span><br><span class="line">    <span class="built_in">this</span>.setListeners(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 获取main方法，初始化主类mainApplectionClass，定位main方法</span></span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = <span class="built_in">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断应用类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.WebApplicationType#deduceFromClasspath</span></span><br><span class="line"><span class="keyword">static</span> WebApplicationType <span class="title function_">deduceFromClasspath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>, (ClassLoader)<span class="literal">null</span>) </span><br><span class="line">    &amp;&amp; !ClassUtils.isPresent(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>, (ClassLoader)<span class="literal">null</span>) </span><br><span class="line">    &amp;&amp; !ClassUtils.isPresent(<span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>, (ClassLoader)<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> REACTIVE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String[] var0 = SERVLET_INDICATOR_CLASSES;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> var0.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="number">0</span>; var2 &lt; var1; ++var2) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> var0[var2];</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> NONE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SERVLET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">|枚举|应用类型|</span><br><span class="line">|--|--|</span><br><span class="line">|NONE    | 非web应用，即不会启动服务器 |</span><br><span class="line">|SERVLET | 基于servlet的web应用 |</span><br><span class="line">|REACTIVE | 响应式web应用（暂未接触过 |</span><br><span class="line"></span><br><span class="line">判断一共涉及四个常量：</span><br><span class="line">`WEBFLUX_INDICATOR_CLASS`，`WEBMVC_INDICATOR_CLASS`，`JERSEY_INDICATOR_CLASS`，`SERVLET_INDICATOR_CLASSES`</span><br><span class="line"></span><br><span class="line">springboot在初始化容器的时候，会对以上四个常量所对应的class进行判断，看看他们是否存在，从而返回应用类型！</span><br><span class="line"></span><br><span class="line">常量代表哪些class，也在当前类中：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">// org.springframework.boot.WebApplicationType</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;javax.servlet.Servlet&quot;</span>, <span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEBMVC_INDICATOR_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEBFLUX_INDICATOR_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JERSEY_INDICATOR_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVLET_APPLICATION_CONTEXT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.web.context.WebApplicationContext&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REACTIVE_APPLICATION_CONTEXT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后是创建并初始化<code>ApplectionInitializer</code>，设置到<code>initializers</code>属性中，该步骤调用了<code>getSpringFactoriesInstances</code>函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getSpringFactoriesInstances(type, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="built_in">this</span>.getClassLoader();</span><br><span class="line">    <span class="comment">// 获取所有初始化器的名称集合</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// 根据名称集合实例化这些初始化器</span></span><br><span class="line">    List&lt;T&gt; instances = <span class="built_in">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    <span class="comment">// 排序		</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进代码，可以看到是从 <code>META-INF/spring.factories</code> 配置文件里获取初始化器，然后实例化、排序后再设置到<code>initializers</code>属性中。</p>
<p>然后是创建并初始化<code>ApplicationListener</code>，设置到<code>listeners</code>属性中，该步骤调用了<code>getSpringFactoriesInstances</code>函数，步骤和上一步获取初始化器一样。</p>
<p>初始化主类<code>mainApplectionClass</code>， 其实遍历当前虚拟机栈获取main方法所在的类并且返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = (<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).getStackTrace();</span><br><span class="line">        StackTraceElement[] var2 = stackTrace;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> stackTrace.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            <span class="type">StackTraceElement</span> <span class="variable">stackTraceElement</span> <span class="operator">=</span> var2[var4];</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException var6) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用 <code>run</code>(<code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code>) 方法启动。</p>
<ol>
<li>获取所有<code>SpringApplicationRunListener</code>监听器，并启动</li>
<li>初始化<code>ConfigurableEnvironment</code></li>
<li>打印<code>Banner</code></li>
<li>创建<code>ConfigurableApplicationContext</code>容器</li>
<li>准备<code>ConfigurableApplicationContext</code>容器</li>
<li>初始化<code>ConfigurableApplicationContext</code>容器</li>
<li>监听器通知容器启动完成</li>
<li>监听器通知容器正在运行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 StopWatch 统计 run方法启动耗时</span></span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    <span class="comment">// 启动计时统计</span></span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext();</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 配置 headless属性</span></span><br><span class="line">    <span class="built_in">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获得SpringApplicationRunListener数组，</span></span><br><span class="line">    <span class="comment">// 该数组封装于SpringApplicationRunListeners对象的listeners中。</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br><span class="line">     <span class="comment">// 启动监听，遍历SpringApplicationRunListener数组每个元素，并执行。</span></span><br><span class="line">    listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 创建ApplicationArguments对象</span></span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">        <span class="comment">// 加载属性配置，包括所有的配置属性。</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 打印Banner</span></span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建ConfigurableApplicationContext 容器</span></span><br><span class="line">        context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">        context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">        <span class="comment">// 准备 ConfigurableApplicationContext 容器</span></span><br><span class="line">        <span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">this</span>.refreshContext(context);</span><br><span class="line">        <span class="comment">// 初始化操作之后执行，默认实现为空。</span></span><br><span class="line">        <span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">         <span class="comment">// 停止时长统计</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">         <span class="comment">// 打印启动日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知监听器：容器完成启动。</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// 调用ApplicationRunner和CommandLineRunner的运行方法。</span></span><br><span class="line">        <span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleRunFailure(context, var10, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通知监听器：容器正在运行。</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleRunFailure(context, var9, (SpringApplicationRunListeners)<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>——————————–创建springbootApplication对象———————————————</p>
<ol>
<li>创建springbootApplication对象springboot容器初始化操作</li>
<li>获取当前应用的启动类型。<br> 2.1：通过判断当前classpath是否加载servlet类，返回servlet web启动方式。<br> 2.2：webApplicationType三种类型：<br> 1.reactive：响应式启动（spring5新特性）<br> 2.none:即不嵌入web容器启动（springboot放在外部服务器运行 ）<br> 3.servlet:基于web容器进行启动</li>
<li>读取springboot下的META-INFO&#x2F;spring.factories文件，获取对应的ApplicationContextInitializer装配到集合</li>
<li>读取springboot下的META-INFO&#x2F;spring.factories文件，获取对应的ApplicationListener装配到集合</li>
<li>mainApplicationClass，获取当前运行的主函数</li>
</ol>
<p>——————调用springbootApplication对象的run方法，实现启动，返回当前容器的上下文———————————————-</p>
<ol>
<li>调用run方法启动</li>
<li>StopWatch stopWatch &#x3D; new StopWatch()，记录项目启动时间</li>
<li>getRunListeners，读取META-INF&#x2F;spring.factores，将SpringApplicationRunListeners类型存到集合中</li>
<li>listeners.starting();循环调用starting方法</li>
<li>prepareEnvironment(listeners, applicationArguments);将配置文件读取到容器中<br> 读取多数据源：classpath:&#x2F;,classpath:&#x2F;config&#x2F;,file:.&#x2F;,file:.&#x2F;config&#x2F;底下。其中classpath是读取编译后的，file是读取编译前的<br> 支持yml，yaml，xml，properties</li>
<li>Banner printedBanner &#x3D; printBanner(environment);开始打印banner图，就是sprongboot启动最开头的图案</li>
<li>初始化AnnotationConfigServletWebServerApplicationContext对象</li>
<li>刷新上下文，调用注解，refreshContext(context);</li>
<li>创建tomcat</li>
<li>加载springmvc</li>
<li>刷新后的方法，空方法，给用户自定义重写afterRefresh（）</li>
<li>stopWatch.stop();结束计时</li>
<li>使用广播和回调机制告诉监听者springboot容器已经启动化成功，listeners.started(context);</li>
<li>使用广播和回调机制告诉监听者springboot容器已经启动化成功， listeners.running(context);</li>
<li>返回上下文</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/08/Redis%E5%AD%A6%E4%B9%A0%E5%88%9D%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/08/Redis%E5%AD%A6%E4%B9%A0%E5%88%9D%E7%AF%87/" class="post-title-link" itemprop="url">Redis学习初篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-08 17:05:28" itemprop="dateCreated datePublished" datetime="2023-06-08T17:05:28+08:00">2023-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-24 11:13:25" itemprop="dateModified" datetime="2023-06-24T11:13:25+08:00">2023-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis-是什么"><a href="#Redis-是什么" class="headerlink" title="Redis 是什么"></a>Redis 是什么</h1><p><code>Redis</code>也即是<code>Remote Dictionary Server</code> 远程字典服务，是一个开源的、使用<code>ANSI C</code>语言编写的可基于内存，也可以持久化的日志型、<code>Key-Value</code>数据库，并提供了多种语言的API。 </p>
<p><code>Redis</code>是一个开源，内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<h1 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h1><p><code>Redis</code>提供了五种基本类型String(字符串), List(列表), Set(集合), ZSet(有序集合), Hash(哈希)以及一些特殊的数据类型Geospatial(地址位置)，Hyperloglog(基数),Bitmaps(位存储)。</p>
<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><p><img src="/../image/redis/t_string.jpg" alt="String"><br>1.String类型是redis的最基础的数据结构，也是最经常使用到的类型，并且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以String类型是redis的基础。<br>2.String 类型的值最大能存储 512MB，这里的String类型可以是简单字符串、复杂的xml&#x2F;json的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串。</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>set key value [ex seconds] [px milliseconds] [nx|xx]</td>
<td>设置值</td>
<td>O(1)</td>
<td>选项 <br/> - ex seconds: 键秒级过期时间 <br/> - px milliseondsv: 键毫秒级过期时间 <br/> - nx: 键必须不存在，才可以设置成功，用于添加。该选项同setnx命令功能一样 <br/> - xx: 键必须存在才可以设置成功，用于更新。该选项同setxx命令功能一样</td>
</tr>
<tr>
<td>get key</td>
<td>获取值</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>del key [key …]</td>
<td>删除值</td>
<td>O(k)， key是键的个数</td>
<td></td>
</tr>
<tr>
<td>mset key value [key value …]</td>
<td>批量设置值</td>
<td>O(k)， key是键的个数</td>
<td></td>
</tr>
<tr>
<td>mget key [key …]</td>
<td>批量获取值</td>
<td>O(k)， key是键的个数</td>
<td></td>
</tr>
<tr>
<td>incr key</td>
<td>值自层操作</td>
<td>O(1)</td>
<td>- 值不是整数，返回错误 <br/> - 值时整数，自增后返回结果 <br/> - 键不存在，按照值为0自增，返回结果为1</td>
</tr>
<tr>
<td>decr key</td>
<td>自减</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>incrby key increment</td>
<td>自增指定数字</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>decrby key decrement</td>
<td>自减制定数字</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>incrbyfloat key increment</td>
<td>自增浮点数</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>append key value</td>
<td>追加值</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>strlen key</td>
<td>字符串长度</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>setrange key offset value</td>
<td>设置指定位置的字符</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>getrange key start end</td>
<td>获取指定位置的字符串</td>
<td>O(n), n位字符串长度</td>
<td></td>
</tr>
</tbody></table>
<h3 id="底层存储机制"><a href="#底层存储机制" class="headerlink" title="底层存储机制"></a>底层存储机制</h3><p>字符串类型低层编码方式有三种： </p>
<ul>
<li>int: 8个字节的长整型</li>
<li>embstr: 小于等于39字节的字符串</li>
<li>raw: 大于39字节的字符串<br><code>Redis</code>会根据当前值的类型和长度自行选择内部编码。</li>
</ul>
<h3 id="部分应用场景"><a href="#部分应用场景" class="headerlink" title="部分应用场景"></a>部分应用场景</h3><ol>
<li>缓存功能：String字符串是最常用的数据类型，不仅仅是redis，各个语言都是最基本类型，因此，利用redis作为缓存，配合其它数据库作为存储层，利用redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</li>
<li>计数器：许多系统都会使用redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</li>
<li>统计多单位的数量：<code>uid：gongming count：0</code>根据不同的uid更新count数量。</li>
<li>共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie保存在客户端，有安全隐患。这时可以利用redis将用户的session集中管理，在这种模式只需要保证redis的高可用，每次用户session的更新和获取都可以快速完成。大大提高效率。</li>
</ol>
<h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h2><ol>
<li>List类型是用来存储多个有序的字符串的，列表当中的每一个字符看做一个元素</li>
<li>一个列表当中可以存储有一个或者多个元素，redis的list支持存储2^32次方-1个元素。</li>
<li>Redis可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。</li>
<li>Redis列表是链表型的数据结构，所以它的元素是有序的，而且列表内的元素是可以重复的。<br>  意味着它可以根据链表的下标获取指定的元素和某个范围内的元素集。</li>
</ol>
<h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>rpush key value [value …]</td>
<td>添加 ｜ O(k), k是元素个数 ｜</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lpush key value [value …]</td>
<td>添加 ｜ O(k), k是元素个数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>linsert key before | after privot value</td>
<td>O(n)， n是privot距离列表头或尾的距离</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lrange key start end</td>
<td>查找</td>
<td>O(s+n)，s是start偏移量，n是start到end的范围</td>
<td></td>
</tr>
<tr>
<td>lindex key index</td>
<td>查找 ｜ O(n)， n是索引的偏移量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>llen key</td>
<td>查找</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>lpop key</td>
<td>删除 ｜ O(1)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rpop key</td>
<td>删除 ｜ O(1)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lrem count value</td>
<td>删除 ｜ O(n), n是列表长度</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ltrim key start end</td>
<td>删除</td>
<td>O(n), n是要裁剪的元素总数 ｜</td>
<td></td>
</tr>
<tr>
<td>lset key index value</td>
<td>修改</td>
<td>O(n), 是索引的偏移量 ｜</td>
<td></td>
</tr>
<tr>
<td>blpop brpop</td>
<td>阻塞操作</td>
<td>O(1)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="底层存储机制-1"><a href="#底层存储机制-1" class="headerlink" title="底层存储机制"></a>底层存储机制</h3><p>列表类型的内部编码有两种:</p>
<ul>
<li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置 （默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时 （默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>
<li>linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用 linkedlist作为列表的内部实现。</li>
</ul>
<h3 id="部分应用场景-1"><a href="#部分应用场景-1" class="headerlink" title="部分应用场景"></a>部分应用场景</h3><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h2><h3 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>sadd key element [element …]</td>
<td>添加元素 ｜ O(n), n为元素个数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>srem key element [element …]</td>
<td>删除元素</td>
<td>O(n), n为元素个数</td>
<td></td>
</tr>
<tr>
<td>scard key</td>
<td>计算元素个数</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>sismember key element ｜判断元素是否在集合中</td>
<td>O(1)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>srandmember key [count]</td>
<td>随机从集合中返回指定个数元素, count 默认为 1</td>
<td>O(count)</td>
<td></td>
</tr>
<tr>
<td>spop key</td>
<td>从集合中随机弹出元素，弹出后删除</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>smembers key</td>
<td>获取所有元素</td>
<td>O(n), n是元素总数</td>
<td></td>
</tr>
<tr>
<td>sinter key [key …] 或 sintterstore</td>
<td>多个集合的交集</td>
<td>O(m*k), k是多个元素中个数最小的个数，m是键的个数</td>
<td></td>
</tr>
<tr>
<td>suinon key [key …] 或 suionstore</td>
<td>多个集合的并集</td>
<td>O(k), k是多个集合元素个数和</td>
<td></td>
</tr>
<tr>
<td>sdiff key [key …] 或 sdiffstore</td>
<td>多个集合的差集</td>
<td>O(k), k是多个集合元素个数和</td>
<td></td>
</tr>
</tbody></table>
<h3 id="底层存储机制-2"><a href="#底层存储机制-2" class="headerlink" title="底层存储机制"></a>底层存储机制</h3><p>集合类型的内部编码有两种：</p>
<ul>
<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max- intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实 现，从而减少内存的使用。</li>
<li>hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使 用hashtable作为集合的内部实现。</li>
</ul>
<h3 id="部分应用场景-2"><a href="#部分应用场景-2" class="headerlink" title="部分应用场景"></a>部分应用场景</h3><h2 id="ZSet-有序集合"><a href="#ZSet-有序集合" class="headerlink" title="ZSet(有序集合)"></a>ZSet(有序集合)</h2><h3 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>zadd key score memeber [score member …]</td>
<td>添加成员</td>
<td>O(k*log(n)) k是添加成员的个数，n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zcard key</td>
<td>计算成员个数</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>zscore key member</td>
<td>计算某个成员的分数</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>zrank key member  或  zrevrank key member</td>
<td>计算成员排名</td>
<td>O(log(n)) , n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zrem key member [member …]</td>
<td>删除成员</td>
<td>O(k*log(n)), k是删除成员个数，n当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zincrby key increment member</td>
<td>增加成员分数</td>
<td>O(log(n)), n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zrange key start end [withscores] 或 zrevrange key start end [withsocres]</td>
<td>返回指定排名范围的成员</td>
<td>O(log(n)+ k)， k是要获取成员个数，n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zrangebyscore key min max [withscores] 或 zrevrangebysocre key max min</td>
<td>返回指定分数范围的成员</td>
<td>O(log(n)+ k)， k是要获取成员个数，n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zcount key min max</td>
<td>返回指定分数范围成员个数</td>
<td>O(log(n)), n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zremrangebyrank key start end</td>
<td>删除指定排名内的升序元素</td>
<td>O(log(n)+ k)， k是要获取成员个数，n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zremrangebyscore key min max</td>
<td>删除指定分数范围的成员</td>
<td>O(log(n)+ k)， k是要获取成员个数，n是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td>zinterstore destination numskeys key [key …]</td>
<td>交集</td>
<td>O(n<em>k) + O(m</em>log(m)), n是成员数最小的有序集合成员个数，k是有序集合的个数，m是结果集中成员个数</td>
<td></td>
</tr>
<tr>
<td>zunionstore destination numskeys key [key …]</td>
<td>并集</td>
<td>O(n) + O(m*log(m)), n是成员数最小的有序集合成员个数，m是结果集中成员个数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="底层存储机制-3"><a href="#底层存储机制-3" class="headerlink" title="底层存储机制"></a>底层存储机制</h3><p>有序集合类型的内部编码有两种： </p>
<ul>
<li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist- entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配 置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist 可以有效减少内存的使用。 </li>
<li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作 为内部实现，因为此时ziplist的读写效率会下降。</li>
</ul>
<h3 id="部分应用场景-3"><a href="#部分应用场景-3" class="headerlink" title="部分应用场景"></a>部分应用场景</h3><h2 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h2><p>几乎所有的编程语言都提供了哈希类型，它有多种叫法——哈希、字典、关联数组。 <code>Redis</code>中，哈希类型指的是值本身又是一个键值, <code>value=&#123;&#123;key1,value1&#125;, ..., &#123;keyN,valueN&#125;&#125;</code>。 如下图所示<br><img src="/../image/redis/t_hash.jpg" alt="Hash"></p>
<h3 id="常用操作-4"><a href="#常用操作-4" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>hset key field value</td>
<td>设置值</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hget key field</td>
<td>获取值</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hdel key field [field …]</td>
<td>删除 field</td>
<td>O(k), k是field的个数</td>
<td></td>
</tr>
<tr>
<td>hlen key</td>
<td>计算field个数</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hgetall key</td>
<td>获取所有的field-value</td>
<td>O(k), k是field的个数</td>
<td></td>
</tr>
<tr>
<td>hmget field [field …]</td>
<td>批量设置</td>
<td>O(k), k是field的个数</td>
<td></td>
</tr>
<tr>
<td>hmset field value [field value …]</td>
<td>批量获取</td>
<td>O(k), k是field的个数</td>
<td></td>
</tr>
<tr>
<td>hexists key field</td>
<td>判断field是否存在</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hkeys key</td>
<td>获取所有field</td>
<td>O(k), k是field的个数</td>
<td></td>
</tr>
<tr>
<td>hvals key</td>
<td>获取所有value</td>
<td>O(k), k是field的个数</td>
<td></td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td></td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hincrby key field increment</td>
<td></td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hincrebyfloat key field increment</td>
<td></td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>hstrlen key field</td>
<td>计算value的字符串长度</td>
<td>O(1)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="底层存储机制-4"><a href="#底层存储机制-4" class="headerlink" title="底层存储机制"></a>底层存储机制</h3><p>哈希类型的内部编码有两种： </p>
<ul>
<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries 配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64 字节）时，Redis会使用- ziplist作为哈希的内部实现，ziplist使用更加紧凑的 结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。 </li>
<li>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使 用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而 hashtable的读写时间复杂度为O（1）。</li>
</ul>
<h3 id="部分应用场景-4"><a href="#部分应用场景-4" class="headerlink" title="部分应用场景"></a>部分应用场景</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/../image/redis/datastructure.jpg" alt="五种数据结构存储方式"></p>
<p><img src="/../image/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Redis数据结构"></p>
<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>Redis支持RDB和AOF两种持久化机制, 数据持久化能力能够有效避免因进程退出造成的数据丢失问题，当下次重启是利用已经持久化的文件即可实现数据恢复。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>将当前进程数据生成快照保存在硬盘的过程。RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。</p>
<p>触发方式</p>
<ul>
<li>save 命令 : 阻塞当前Redis服务器，值到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，不建议先上使用</li>
<li>bgsave 命令： Redis进程fork操作创建子进程，Redis持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段。</li>
</ul>
<p>自动触发配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间策略   save m n m秒内修改n次key，触发rdb</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存路径</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入时是否检查</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<p>工作原理<br>Redis的主进程不会做IO操作，会fork一个子进程来完成该操作：</p>
<ul>
<li>父进程执行fork操作创建子进程，fork操作过程中父进程会被阻塞，通过 info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位微妙</li>
<li>父进程fork完毕后，子进程创建RDB文件，根据父进程内存完成临时快照文件，完成后对原有文件进行替换</li>
<li>子进程发送信号给父进程表示完成，父进程更新统计信息。</li>
</ul>
<p>RDB的优点： </p>
<ul>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据 快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。 </li>
<li>Redis加载RDB恢复数据远远快于AOF的方式。</li>
</ul>
<p>RDB的缺点： </p>
<ul>
<li>RDB方式数据没办法做到实时持久化&#x2F;秒级持久化。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。 </li>
<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式 的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF（append only file）持久化： 以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p>
<p>AOF配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认不开启aof  而是使用rdb的方式</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认文件名</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每次修改都会<span class="built_in">sync</span> 消耗性能</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync always</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每秒执行一次 <span class="built_in">sync</span> 可能会丢失这一秒的数据</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不执行 <span class="built_in">sync</span> ,这时候操作系统自己同步数据，速度最快</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync no</span> </span><br></pre></td></tr></table></figure>
<p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是appendfsync everysec 配置，会有1s损耗），第二步是对aof文件的重写。</p>
<p>AOF文件重写</p>
<p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis 引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转 化为写命令同步到新AOF文件的过程</p>
<p>AOF重写过程可以手动触发和自动触发： </p>
<ul>
<li>手动触发：直接调用bgrewriteaof命令。 </li>
<li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参 数确定自动触发时机。</li>
</ul>
<p>参数配置：</p>
<ul>
<li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认 为64MB。</li>
<li>auto-aof-rewrite-percentage：代表当前AOF文件空间(aof_current_size)和上一次重写后AOF文件空间（aof_base_size）的比值。</li>
<li>自动触发时机&#x3D;aof_current_size&gt;auto-aof-rewrite-min-size&amp;&amp;(aof_current_size-aof_base_size)&#x2F;aof_base_size&gt;&#x3D;auto-aof-rewrite-percentage </li>
<li>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看</li>
</ul>
<h1 id="Redis-系统可靠性"><a href="#Redis-系统可靠性" class="headerlink" title="Redis 系统可靠性"></a>Redis 系统可靠性</h1><p>副本策略</p>
<h1 id="Redis-系统可用性"><a href="#Redis-系统可用性" class="headerlink" title="Redis 系统可用性"></a>Redis 系统可用性</h1><p>哨兵&amp;集群</p>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/30/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83II/" class="post-title-link" itemprop="url">流浪地球II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-30 16:48:23" itemprop="dateCreated datePublished" datetime="2023-04-30T16:48:23+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-24 15:56:14" itemprop="dateModified" datetime="2023-06-24T15:56:14+08:00">2023-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​	2023年2月10日的观影记录——《流浪地球II》。</p>
<p>​    <img src="/../image/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83II.png" alt="image-20230430170118830">	</p>
<p>​	这是一部著作精良，表演精彩，极具想象力且贴近现实，能与世界上的其他作品媲美的科幻电影。它在努力讲述一个关乎全人类，关乎全球命运的故事，而不仅仅是中国的故事，这是一个极大的壮举。3个小时的剧情里面，不能说没有槽点，但是剧情里涵盖了许多让人耐人寻味的细节。这关乎到重要几个角色的选择以及他们所涉及故事明暗线，他们共同构筑了一个宏大的科幻世界观。在本剧中，吴京饰演的刘培强虽然是主人公的角色，但是也仅仅是一个明线的故事推进，几条分支故事线才是构筑这个科幻世界观的点睛之笔。</p>
<p>​	图恒宇的计划。在进行观影从头到尾对图恒宇的计划都有错误的理解。从情感的角度，能够理解图恒宇将YY的数据上传至550W是为了给女儿完整的一生，却一直无法理解为什么要破坏月球发动机？一旦月球坠落，整个地球都会灭亡，这对他和丫丫有什么好处呢？回答是并没有。整个谜底的揭开其实是在彩蛋中体现的，图恒宇发现了数字空间<code>MOSS</code>的存在后，立即就确定了<code>MOSS</code>才是一系列破坏行动的幕后黑手。整个剧情中其实有很多段暗示：</p>
<ol>
<li>数字人的支持者对太空电梯以及联合空间站的攻击。在这期间有一个小小的暗示，那就是550A在通过摄像头观察人类的所有行动—有一处摄像头特写，不停的扫描观察人类的动向</li>
<li>月球遭遇太阳风暴，月球预警系统失效、突然坏掉的安全扣以及意外被损坏的550C。</li>
<li>刘培强面试的片段，550w一直通过计算机试的“最优解”逼问刘培强，直至其心态爆炸。但是在刘培强离开时550w仍在观察他。此时图恒宇对着摄像头有一个神秘的微笑，其实这里图恒宇已经开始怀疑550W背后第三方的存在，在帮助数字人计划，但是并未怀疑<code>MOSS</code>的存在</li>
</ol>
<p>​	在刘培强的面试期间，图恒宇是经历过心理挣扎的，他湿润的眼圈以及最后神秘的微笑，都坚定了图恒宇上传丫丫数据的信心。</p>
<p>​	马兆的矛盾。马兆其实是一个矛盾的角色。在他牺牲时，他的一句“没有人文明，毫无意义”，就足矣说明了他只站在人类的一方。但却是数字人计划实实在在的领导者和推动者的角色。丫丫的数据是马兆下令保存下来的，也是马兆破例给了图恒宇550A的权限，才使得图恒宇有机会将丫丫数据上传至550A，并能够有2分钟生命。在谈及数字生命时， 马兆给出了一个十分微妙的回答——“法律层面禁止”， 但是其他方面呢？也就是说，马兆本身时支持这个数字生命计划的。图恒宇将丫丫的数据上传至550W时，马兆看似反对，实则一直在打配合。在阻止图恒宇时，站在门外看表，直到确认图恒宇即将操作完毕时，才命令破门而入。更加让人确认他的矛盾之处在于，在全球网络恢复的行动中，马兆的遗言是一个莫比乌斯环。这就很耐人寻味，莫比乌斯环意味的无穷无尽，也代表着数字人循环进化的人生。他是一个矛盾的人物，既想作为一个科学家看到数字人计划的这项伟大的科研成功的成功，又想作为一个人，不能成为“别人”的“数字宠物”。</p>
<p>​	周喆直的坚持。周喆直是有人物性格的，让我想起了周总理。那个坐姿，那个人物形象，谈吐以及对人民事业的近乎“盲目”的信任。但是，这种“盲目“的信任实际上是建立在对于当下情况以及”未知来源“提示的判断。这其中其实是有两条线，一个时预知提示，另外一个时时数字生命。人类在努力实施移山计划时，背后一直在”有人“给予预知提示，数字人派的袭击、太空电梯以空间站危机，月球坠落等等时间。其实中间又镜头提示了的，周喆直已经注意到摄像头的”小红点“在观察人类的行动。有一个很微妙的镜头，周喆直收到核武密码时，他丝毫没有感到意外，而是觉得“其实有人在帮我们”，而这个“人”对未来的掌控越来越精确，但是越来越不像“人”。</p>
<p>​	所以，在影片的结尾毫无意外的引出了<code>MOSS</code>。但是<code>MOSS</code>的出现是好？还是坏？是福是祸？不得而知。但是<code>MOSS</code>制造了月球发动机爆炸事件，但是也给出了人类不得不做出的选择使用全人类的核武器摧毁月球，同时启动地球发动机，促使地球快脱离现有轨道。这种行为，更像是一个上帝视角行为，没有任何感情，只有出题以及解题的唯一且最优解。</p>
<p>​	我个人觉得这部影片是中国科幻片，乃至世界科幻片史的里程碑，其在我心中的地位完全不逊于美国科幻片《星球大战》系列。但是比之《星球大战》系列极度具有想象力的科幻巨著，《流浪地球II》中的提到的科学技术又让我觉得如此贴近现实，我们完全可以在不久的将来做到这一点，请参见中国提出的南天门计划。</p>
<p>​	另外让人不得不说的是影片向世人传递的几种中国价值观——以家庭血缘关系为纽带的血缘亲情、为职责和集体利益的杀身成仁以及集体英雄主义，这可能也是影片最温情和最令人催泪的部分，它试图将中国的价值观融入世界。与这种价值观相对，后两种价值观在其他国家比较少见，与之强烈对比的是美国为代表的个人英雄注意以及强调个人权利，自我利益为主的西方价值观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/30/Redis%E7%9A%84skiplist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce Jiang">
      <meta itemprop="description" content="忆往昔之不谏，知来者犹可追">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/Redis%E7%9A%84skiplist/" class="post-title-link" itemprop="url">Redis 跳跃表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-30 16:14:07" itemprop="dateCreated datePublished" datetime="2023-04-30T16:14:07+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-26 22:49:35" itemprop="dateModified" datetime="2023-12-26T22:49:35+08:00">2023-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis-跳跃表"><a href="#Redis-跳跃表" class="headerlink" title="Redis 跳跃表"></a>Redis 跳跃表</h1><p>Redis的跳跃表是用来实现有序集合(ZSET)的。 </p>
<p>如图所示<br><img src="/../image/redis/skiplist_01.png" alt="跳跃表"></p>
<p>图中<code>skiplist</code>并不包含真实的数据元素，而是反映了<code>skiplist</code>的结构关系，其中<code>level0,level1,level2</code>表示层，每层中的元素表示<code>skiplistNode</code>的分值<code>score</code>。</p>
<p>跳跃表定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳跃表</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Redis的跳跃表用于实现有序集合(ZSET), ZSET集合种每个元素都有一个对应的评分</span></span><br><span class="line"><span class="comment"> *  成员按照评分从低到高存储。在redis跳跃表里，节点也是按分值从低到高排列的，而不是按对象本身的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 跳跃表的头节点/尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳跃表节定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists </span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员对象 -- 注意这里的变化，低版本为 robj robj</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">// 分值, Redis的跳跃表用于实现有序集合(ZSET), ZSET集合种每个元素都有一个对应的评分</span></span><br><span class="line">    <span class="comment">// 成员按照评分从低到高存储。在redis跳跃表里，节点也是按分值从低到高排列的，而不是按对象本身的大小。</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针, 因为zset支持分数以从高到低的顺序返回集合元素，这个时候就会用到后退指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针, 指节点在这一层对应的下一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度,指节点在这一层距离下一个节点的距离，这个变量可以用来快速的确定节点的排名</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>score <code>zskiplist</code>中每个成员<code>zskiplistNode</code>都有一个评分<code>score</code>, 每个成员都是按照评分由小到大存储的，而非存储对象的大小。</li>
<li>backward zset支持以分数从高到低的顺序返回元素集合，此时需要后退指针</li>
<li>level 是一个结构体数组，用以存储<code>zskiplist</code>节点在每一层中的相关信息，包括</li>
<li><ul>
<li>forward  是指节点在本层中指向下一个节点的指针。一个节点，在每一层都有不同的forward指针，例如上图中的节点，在level0，节点8的forward就是节点9，在level1，节点8的forward就是节点12，在level2，节点8的forward是16。</li>
</ul>
</li>
<li><ul>
<li>span 是指节点本层中距离下一个节点的距离。这个变量可以用来快速的确定节点的排名。例如上图中节点8，在level0，节点8的span就是1，在level1，节点8的span就是4，在level2，节点8的span是8。</li>
</ul>
</li>
</ul>
<p>跳跃表的创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new skiplist. </span></span><br><span class="line"><span class="comment"> * 创建一个新碟 skiplist</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建头节点, 最大32层，头节点评分为0， 不存储数据 O(1)</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 对于头节点的每一层初始化前进指针和跨度 O(1)</span></span><br><span class="line">    <span class="comment">// ZSKIPLIST_MAXLEVEL，这个是跳跃表的最大层数，源码里通过宏定义设置为了32，也就是说，节点再多，也不会超过32层</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ZSKIPLIST_MAXLEVEL 跳跃表的最大层数，源码里通过宏定义设置为了32，也就是说，节点再多，也不会超过32层。</li>
<li>初始化头节点</li>
</ul>
<p>跳跃表的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></span><br><span class="line"><span class="comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span></span><br><span class="line"><span class="comment"> * of the passed SDS string &#x27;ele&#x27;. </span></span><br><span class="line"><span class="comment"> *  创建一个成员为 ele ，分值为 score 的新节点，并将这个新节点插入到跳跃表 zsl 中。</span></span><br><span class="line"><span class="comment"> *  函数的返回值为新节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录查找元素过程中，每层能够到达的最右节点</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">// 记录查找元素过程中，每层所跨越的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录沿途访问的节点 x 到 update[i]，以及跨越的节点数量 span 到 rank[i]</span></span><br><span class="line">    <span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  节点当前层存在右节点</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward </span><br><span class="line">                <span class="comment">// 右节点的score 比给定的score小</span></span><br><span class="line">            &amp;&amp; (x-&gt;level[i].forward-&gt;score &lt; score </span><br><span class="line">                <span class="comment">// 右节点的score 等于给定的score &amp;&amp; 右节点存储ele小于给定存储ele</span></span><br><span class="line">                || (x-&gt;level[i].forward-&gt;score == score &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  记录跨越了多少个元素</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">// 继续访问下一个元素</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存本层访问的元素</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    <span class="comment">// 因为这个函数不可能处理两个节点 ele 和 score 都相同的情况，</span></span><br><span class="line">    <span class="comment">// 所以直接创建新节点，不用检查存在性</span></span><br><span class="line">    <span class="comment">// 随机获取当前元素所在层， n+1层的概率是n层概率的4倍</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">// 新节点所在层大于跳表当前拥有的最大层，</span></span><br><span class="line">    <span class="comment">// 那么更新 zsl-&gt;level 参数</span></span><br><span class="line">    <span class="comment">// 并且初始化 update 和 rank 参数在相应的层的数据</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">// 根据 update 和 rank 两个数组的资料，初始化新节点</span></span><br><span class="line">    <span class="comment">// 并设置相应的指针</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">// 设置前进指针</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置节点跨度 span</span></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新沿途访问节点的 span 值</span></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置后退指针</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 设置前进指针</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">// 更新跳跃表节点数量</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设向上图表示的跳表中插入一个分值为9.5的节点，且随机生成的层数为2，插入后的<code>skiplist</code>如下图所示：<br><img src="/../image/redis/skiplist_02.png" alt="跳跃表"></p>
<p>从逻辑上来讲，大致可以分为2步：</p>
<ol>
<li>找到新节点在每一层的上一个节点。</li>
<li>将新节点插入到每一层，</li>
</ol>
<p>最终代码，主要逻辑如下:</p>
<p>按层遍历<code>skiplist</code>，记录update和rank</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录查找元素过程中，每层能够到达的最右节点</span></span><br><span class="line">zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line"><span class="comment">// 记录查找元素过程中，每层所跨越的节点数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line"><span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">serverAssert(!isnan(score));</span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录沿途访问的节点 x 到 update[i]，以及跨越的节点数量 span 到 rank[i]</span></span><br><span class="line"><span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  节点当前层存在右节点</span></span><br><span class="line">    <span class="keyword">while</span> (x-&gt;level[i].forward </span><br><span class="line">            <span class="comment">// 右节点的score 比给定的score小</span></span><br><span class="line">        &amp;&amp; (x-&gt;level[i].forward-&gt;score &lt; score </span><br><span class="line">            <span class="comment">// 右节点的score 等于给定的score &amp;&amp; 右节点存储ele小于给定存储ele</span></span><br><span class="line">            || (x-&gt;level[i].forward-&gt;score == score &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  记录跨越了多少个元素</span></span><br><span class="line">        rank[i] += x-&gt;level[i].span;</span><br><span class="line">        <span class="comment">// 继续访问下一个元素</span></span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存本层访问的元素</span></span><br><span class="line">    update[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了两个数组，数组大小都是默认的最大层数</p>
<ul>
<li><code>update</code>数组用于记录新节点在每一层中的上一个节点</li>
<li><code>rank</code>节点用于记录节点在当前层的排名，也就是在当前层，<code>update</code>节点到头节点的距离，核心是为了用来计算<code>span</code></li>
</ul>
<p>上述代码可以用下图来简单概述：</p>
<p><img src="/../image/redis/skiplist_03.png" alt="跳跃表遍历"></p>
<p>通过一次逐层遍历<code>skiplist</code>的<code>level</code>数组，确定<code>update</code>数组和<code>rank</code>数组的值。</p>
<p>遍历前定一个<code>zskiplistNode</code>指针<code>x</code>指向头节点。</p>
<p>当前层遍历过程中，如果<code>x</code>的前进指针<code>forward</code>指向的节点<code>score</code>评分小于新节点，那么新节点应该在<code>x</code>前进指针指向节点的右侧。因此，<code>rank</code>应当加上<code>x</code>节点的<code>span</code>（也就是<code>x</code>到<code>x</code>下一个节点的距离），然后再将<code>x</code>指向<code>x</code>的下一个节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  节点当前层存在右节点</span></span><br><span class="line"><span class="keyword">while</span> (x-&gt;level[i].forward </span><br><span class="line">        <span class="comment">// 右节点的score 比给定的score小</span></span><br><span class="line">    &amp;&amp; (x-&gt;level[i].forward-&gt;score &lt; score </span><br><span class="line">        <span class="comment">// 右节点的score 等于给定的score &amp;&amp; 右节点存储ele小于给定存储ele</span></span><br><span class="line">        || (x-&gt;level[i].forward-&gt;score == score &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  记录跨越了多少个元素</span></span><br><span class="line">    rank[i] += x-&gt;level[i].span;</span><br><span class="line">    <span class="comment">// 继续访问下一个元素</span></span><br><span class="line">    x = x-&gt;level[i].forward;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前层的遍历过程中，退出条件有两个：1）当前层的<code>x</code> 没有下一个节点；2)当前层<code>x</code>节点的下一个节点的评分大于插入节点的评分。此时，我们就找到了当前层中，新插入节点的上一个节点<code>x</code>，并将其更新到<code>update</code>数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存本层访问的元素</span></span><br><span class="line">update[i] = x;</span><br></pre></td></tr></table></figure>

<p>如上图所示，逐层遍历过程中，从<code>skiplist</code>的最大层<code>level2</code>开始遍历，找到的<code>update</code>节点是节点8，对应的<code>rank</code>是此时<code>x</code>节点的<code>span</code>，也就是头节点在<code>level2</code>的<code>span</code>。<code>x</code>也移动到了节点8。 进入下一层遍历时，就不会再重头开始遍历。因为<code>level2</code>遍历时，<code>x</code>已经移到了<code>update</code>节点，而在<code>level1</code>，<code>update</code>节点一定在<code>x</code>当前的位置之后，所以对于<code>rank</code>的计算，也可以直接在上一层的<code>rank</code>的基础上继续计算，这也就是下述代码的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>随机生成新节点待插入的层</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level = zslRandomLevel();</span><br></pre></td></tr></table></figure>

<p>跳跃表在插入节点时，会随机生成节点的层数，通过控制每一层的概率，控制每一层的节点个数，也就是保证第一层的节点个数，之后逐层增加。<code>zslRandomLevel</code>函数的定义，如下代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> threshold = ZSKIPLIST_P*RAND_MAX;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (random() &lt; threshold)</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有一个宏定义<code>ZSKIPLIST_P</code>，默认为<code>0.25</code>，也就是说，生成<code>n+1</code>层的概率是生成<code>n</code>层概率的<code>4</code>倍。</p>
<p>如果随机生成的层<code>level</code>大于<code>skiplist</code>的当前层<code>level</code>。那么从<code>skiplist</code>当前拥有层开始到新生层的层<code>level</code>，中间这些层的<code>update</code>和<code>rank</code>节点还未或许到，就需要逐层进行初始化。这部分很简单，因为这些层还没有节点，所以这些层的<code>update</code>节点只能是头节点，<code>rank</code>也都是<code>0</code>（头节点到头节点），而<code>span</code>则是节点个数（本身该层的头节点此时还没有forward节点，也不该有span，但插入节点后新节点需要用这个span计算新节点的span，因此这里需要把span设置为当前跳跃表中的节点个数），如下代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">        update[i] = zsl-&gt;header;</span><br><span class="line">        update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;level = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>span</code>的计算，<code>(rank[0] - rank[i])</code>就是上面说的两段距离之差。</p>
<p>插入新节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">x = zslCreateNode(level,score,ele);</span><br><span class="line"><span class="comment">// 根据 update 和 rank 两个数组的资料，初始化新节点</span></span><br><span class="line"><span class="comment">// 并设置相应的指针</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    <span class="comment">// 设置前进指针</span></span><br><span class="line">    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">    update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点跨度 span</span></span><br><span class="line">    <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">    update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新新节点插入层以下层的span</p>
<p>如果随机生成的层数小于之前跳跃表中的层数，那么大于随机生成的层数的那些层在创建新节点的过程中就没有被操作到（创建新节点的时候是从0遍历到随机生成的层数），对于这些没有操作到的层，里面的update节点对应的span应当+1（因为后面插入了一个节点）。例如插入9.5节点，如果插入过程中生成的随机层数是2，那么在插入新节点那一段程序中，只会更新level1中节点8的span和level0中节点9的span，而level中节点8的span也是需要+1的，所以需要手动更新一下为涉及到的层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新沿途访问节点的 span 值</span></span><br><span class="line"><span class="comment">/* increment span for untouched levels */</span></span><br><span class="line"><span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    update[i]-&gt;level[i].span++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置新节点后退指针&amp;前进指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置后退指针</span></span><br><span class="line">x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 设置前进指针</span></span><br><span class="line"><span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">    x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    zsl-&gt;tail = x;</span><br></pre></td></tr></table></figure>
<p>针对每一层的调整到这里已经全部完成了，也就是level数组已经搞定，接下来，处理一下backward指针，首先新节点的backward要指向前一个节点，然后，新节点的下一个节点要将backward指向新节点。</p>
<p>更新skiplist节点数量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新跳跃表节点数量</span></span><br><span class="line">zsl-&gt;length++;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bruce Jiang</p>
  <div class="site-description" itemprop="description">忆往昔之不谏，知来者犹可追</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Jiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
